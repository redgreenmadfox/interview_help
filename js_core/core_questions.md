<details>
  <summary>1. Какие типы данных существуют в JavaScript?</summary>

  * Число «number» - Единый тип число используется как для целых, так и для дробных чисел. Существуют специальные числовые значения Infinity (бесконечность) и NaN (ошибка вычислений). Например, бесконечность Infinity получается при делении на ноль. Ошибка вычислений NaN будет результатом некорректной математической операции.
  * Строка «string»
  * Булевый (логический) тип «boolean»
  * Специальное значение «null» - В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках. Это просто специальное значение, которое имеет смысл «ничего» или «значение неизвестно».
  * Специальное значение «undefined» - Значение undefined, как и null, образует свой собственный тип, состоящий из одного этого значения. Оно имеет смысл «значение не присвоено». Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.
  * Символы «symbol» - «Символ» представляет собой уникальный идентификатор. Создаются новые символы с помощью функции Symbol(). Символы гарантированно уникальны. Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы. Описание – это просто метка, которая ни на что не влияет.
  * Тип «number» не может содержать числа больше, чем (2^53-1), или меньше, чем -(2^53-1). Тип «bigint» даёт возможность работать с целыми числами произвольной длины.
  * Объекты «object» - Первые 7 типов называют «примитивными». Особняком стоит восьмой тип: «объекты». Он используется для коллекций данных и для объявления более сложных сущностей. Объявляются объекты при помощи фигурных скобок {...}
</details>

<details>
  <summary>2. Что такое цикл событий (event loop) и как он работает?</summary>

  Движок браузера выполняет JavaScript в одном потоке. Для потока выделяется область памяти — стэк, где хранятся фреймы (аргументы, локальные переменные) вызываемых функций.

  Список событий, подлежащих обработке формируют очередь событий. Когда стек освобождается, движок может обрабатывать событие из очереди. Координирование этого процесса и происходит в event loop.

  Это по сути бесконечный цикл, в котором выполняются многочисленные обработчики событий. Если очередь пустая — движок браузера ждет, когда поступит событие. Если непустая — первое в ней событие извлекается и его обработчик начинает выполняться. И так до бесконечности.

  ![alt text](https://camo.githubusercontent.com/ecf21f14bbad63d7c1a0d84b401746af15cd643392bb21aca618fef6c78b0e48/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a71757954494f733268696f4378316a5251372d6f6a772e706e67)
</details>

<details>
  <summary>3.Что такое замыкание?</summary>

  Замыкание — это комбинация функции и лексического окружения, в котором эта функция была объявлена. Это окружение состоит из произвольного количества локальных переменных, которые были в области действия функции во время создания замыкания.
</details>

<details>
  <summary>4.Что такое прототип объекта в JavaScript?</summary>

  Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. Связующим звеном выступает специальное свойство __proto__

  Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. Недостаток этого подхода – он не работает в IE10-.

  К счастью, в JavaScript с древнейших времён существует альтернативный, встроенный в язык и полностью кросс-браузерный способ. Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.

  При создании объекта через new, в его прототип __proto__ записывается ссылка из prototype функции-конструктора.

  Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.
</details>

<details>
  <summary>5. Как работает ключевое слово this?</summary>

  В глобальном контексте выполнения (за пределами каких-либо функций), this ссылается на глобальный объект вне зависимости от использования в строгом или нестрогом режиме.

  В пределах функции значение this зависит от того, каким образом вызвана функция:

  Простой вызов - В этом случае значение this не устанавливается вызовом. Так как этот код написан не в строгом режиме, значением this всегда должен быть объект, по умолчанию - глобальный объект. В строгом режиме, значение this остается тем значением, которое было установлено в контексте исполнения. Если такое значение не определено, оно остается undefined. Для того что бы передать значение this от одного контекста другому необходимо использовать call или apply
  В стрелочных функциях, this привязан к окружению, в котором была создана функция. В глобальной области видимости, this будет указывать на глобальный объект.
  Когда функция вызывается как метод объекта, используемое в этой функции ключевое слово this принимает значение объекта, по отношению к которому вызван метод.
</details>

<details>
  <summary>6. Как работают методы apply(), call() и bind()?</summary>

  Функции в JavaScript никак не привязаны к своему контексту this, с одной стороны, здорово – это позволяет быть максимально гибкими, одалживать методы и так далее.

  Но с другой стороны – в некоторых случаях контекст может быть потерян. Способы явно указать this - методы bind, call и apply.

  Синтаксис метода call: func.call(context, arg1, arg2, ...)

  При этом вызывается функция func, первый аргумент call становится её this, а остальные передаются «как есть». Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).

  Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply. Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.

  func.call(context, arg1, arg2) идентичен вызову func.apply(context, [arg1, arg2]);

  Синтаксис встроенного bind: var wrapper = func.bind(context, [arg1, arg2...])

  Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.
</details>

<details>
  <summary>7. Что такое Promise (Промис)?</summary>

  Promise – это специальный объект, который содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

  Синтаксис создания Promise:

  ```
  var promise = new Promise(function(resolve, reject) {
    // Эта функция будет вызвана автоматически

    // В ней можно делать любые асинхронные операции,
    // А когда они завершатся — нужно вызвать одно из:
    // resolve(результат) при успешном выполнении
    // reject(ошибка) при ошибке
  })
  ```
  Универсальный метод для навешивания обработчиков:

  promise.then(onFulfilled, onRejected)
  onFulfilled – функция, которая будет вызвана с результатом при resolve.
  onRejected – функция, которая будет вызвана с ошибкой при reject.
  Для того, чтобы поставить обработчик только на ошибку, вместо .then(null, onRejected) можно написать .catch(onRejected) – это то же самое.
  Возьмём setTimeout в качестве асинхронной операции, которая должна через некоторое время успешно завершиться с результатом «result»:

  ```
  // Создаётся объект promise
  let promise = new Promise((resolve, reject) => {

    setTimeout(() => {
      // переведёт промис в состояние fulfilled с результатом "result"
      resolve("result");
    }, 1000);

  });
  ```

  ```
  // promise.then навешивает обработчики на успешный результат или ошибку
  promise
    .then(
      result => {
        // первая функция-обработчик - запустится при вызове resolve
        alert("Fulfilled: " + result); // result - аргумент resolve
      },
      error => {
        // вторая функция - запустится при вызове reject
        alert("Rejected: " + error); // error - аргумент reject
      }
    );
  ```

  В результате запуска кода выше – через 1 секунду выведется «Fulfilled: result».
</details>

<details>
  <summary>8. Что такое статический метод класса (static)?</summary>

  Ключевое слово static используется в классах для определения статичных методов. Статичные методы функции, принадлежащие объекту класса, но не доступные другим объектам того же класса.

  ```
  class Repo {
    static getName() {
      return "Repo name is modern-js-cheatsheet"
    }
  }
  ```

  // нам не нужно создавать объект класса Repo
  ```
  console.log(Repo.getName()) // "Repo name is modern-js-cheatsheet"
  ```

  ```
  let r = new Repo();
  console.log(r.getName()) // необработанная ошибка TypeError: r.getName не является функцией
  ```
  Cтатические методы вызываются через имя класса. Вызывать статические методы через имя объекта запрещено. Статические методы часто используются для создания вспомогательных функций приложения.
</details>

<details>
  <summary></summary>

  
</details>

<details>
  <summary>9. Что такое Set, Map, WeakSet и WeakMap?</summary>

  В ES-2015 появились новые типы коллекций в JavaScript: Set, Map, WeakSet и WeakMap.

  Map – коллекция для хранения записей вида ключ:значение. В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например:

  ```
  'use strict';

  let map = new Map();

  map.set('1', 'str1');   // ключ-строка
  map.set(1, 'num1');     // число
  map.set(true, 'bool1'); // булевое значение

  // в обычном объекте это было бы одно и то же,
  // map сохраняет тип ключа
  alert( map.get(1)   ); // 'num1'
  alert( map.get('1') ); // 'str1'

  alert( map.size ); // 3
  ```

  Set – коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз. Например, к нам приходят посетители, и мы хотели бы сохранять всех, кто пришёл. При этом повторные визиты не должны приводить к дубликатам, то есть каждого посетителя нужно «посчитать» ровно один раз. Set для этого отлично подходит:

  ```
  'use strict';

  let set = new Set();

  let vasya = {name: "Вася"};
  let petya = {name: "Петя"};
  let dasha = {name: "Даша"};

  // посещения, некоторые пользователи заходят много раз
  set.add(vasya);
  set.add(petya);
  set.add(dasha);
  set.add(vasya);
  set.add(petya);

  // set сохраняет только уникальные значения
  alert( set.size ); // 3

  set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
  ```

  WeakSet – особый вид Set, не препятствующий сборщику мусора удалять свои элементы. То же самое – WeakMap для Map. То есть, если некий объект присутствует только в WeakSet/WeakMap – он удаляется из памяти. Это нужно для тех ситуаций, когда основное место для хранения и использования объектов находится где-то в другом месте кода, а здесь мы хотим хранить для них «вспомогательные» данные, существующие лишь пока жив объект. Например, у нас есть элементы на странице или, к примеру, пользователи, и мы хотим хранить для них вспомогательную информацию, например обработчики событий или просто данные, но действительные лишь пока объект, к которому они относятся, существует. Если поместить такие данные в WeakMap, а объект сделать ключом, то они будут автоматически удалены из памяти, когда удалится элемент. Например:

  ```
  // текущие активные пользователи
  let activeUsers = [
    {name: "Вася"},
    {name: "Петя"},
    {name: "Маша"}
  ];

  // вспомогательная информация о них,
  // которая напрямую не входит в объект юзера,
  // и потому хранится отдельно
  let weakMap = new WeakMap();

  weakMap.set(activeUsers[0], 1);
  weakMap.set(activeUsers[1], 2);
  weakMap.set(activeUsers[2], 3);
  weakMap.set('Katya', 4); //Будет ошибка TypeError: "Katya" is not a non-null object

  alert( weakMap.get(activeUsers[0]) ); // 1

  activeUsers.splice(0, 1); // Вася более не активный пользователь

  // weakMap теперь содержит только 2 элемента

  activeUsers.splice(0, 1); // Петя более не активный пользователь

  // weakMap теперь содержит только 1 элемент
  ```
</details>
  
  
  
  